var documenterSearchIndex = {"docs":
[{"location":"Maths/#Maths","page":"Maths","title":"Maths","text":"","category":"section"},{"location":"Maths/#Introduction","page":"Maths","title":"Introduction","text":"","category":"section"},{"location":"Maths/","page":"Maths","title":"Maths","text":"These are just a few, geometry related maths functions used all over the place.","category":"page"},{"location":"Maths/#API","page":"Maths","title":"API","text":"","category":"section"},{"location":"Maths/","page":"Maths","title":"Maths","text":"Pages = [\"Maths.md\"]","category":"page"},{"location":"Maths/","page":"Maths","title":"Maths","text":"Modules = [CoolWalksUtils]\nPages = [\"Maths.jl\"]","category":"page"},{"location":"Maths/#CoolWalksUtils.intersection_distances-NTuple{4, Any}","page":"Maths","title":"CoolWalksUtils.intersection_distances","text":"intersection_distances(a, b, c, d)\n\nreturns the solution to a * (1-x1) + b * x1 == c * (1-x2) + d * x2.\n\njulia> intersection_distances([0,0], [1,1], [5,0], [0,5])\n2-element Vector{Float64}:\n 2.5\n 0.5\n\njulia> intersection_distances([0,0.0], [1,1], [4.0, 0.0], [10.0, 2.0])\n2-element Vector{Float64}:\n -2.0\n -1.0\n\n\n\n\n\n","category":"method"},{"location":"Maths/#CoolWalksUtils.is_ccw-Tuple{Any, Any, Any}","page":"Maths","title":"CoolWalksUtils.is_ccw","text":"is_ccw(a, b, c)\n\ntests if the 2D points a, b, c form a counterclockwise triangle.\n\njulia> is_ccw([0,0], [1,0], [1,1])\ntrue\n\njulia> is_ccw([0,0], [0,1], [1.4, 0.5])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Maths/#CoolWalksUtils.is_convex-Tuple{AbstractVector}","page":"Maths","title":"CoolWalksUtils.is_convex","text":"is_convex(polygon)\n\ntests if the exterior of the GeoInterface compatible polygon is convex.\n\nis_convex(points::AbstractVector)\n\ntests if vector of 2D points points describes a convex polygon.\n\nAssumes that points[1] == points[end].\n\njulia> square = [[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]];\n\njulia> is_convex(square)\ntrue\n\njulia> thing = [[0.6, 0.6], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0], [0.6, 0.6]];\n\njulia> is_convex(thing)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Maths/#CoolWalksUtils.is_left-Tuple{Any, Any, AbstractVector}","page":"Maths","title":"CoolWalksUtils.is_left","text":"checks if test_point is left of the line going through center_point in the direction of -sunpos. (sunpos points AT the sun, has three entries. The last on will be set to 0.)\n\nSignatures\n\nis_left(center_point, test_point, sunpos::AbstractVector)\n\ncenter_point and test_point can be any GeoInterface compatible points.\n\nis_left(center_point::AbstractVector, test_point::AbstractVector, sunpos::AbstractVector)\n\ncenter_point and test_point can be eiter 3 or 2 entry long vectors. In the later case, we add a third entry ==0.\n\nExamples\n\njulia> is_left([0, 0], [1, 1], [-1, 0, 0])\ntrue\n\njulia> is_left([0.5, 0.5, 0.0], [1, 1, 0.0], [1, 0, 0])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Maths/#CoolWalksUtils.switches_side-NTuple{4, Any}","page":"Maths","title":"CoolWalksUtils.switches_side","text":"switches_side(a, b, c, d)\n\ntests if the line defined by the 2D points a, b intersects the line segment defined by the 2D points c,d.\n\njulia> switches_side([0,0], [1,1], [5,0], [0,5])\ntrue\n\njulia> switches_side([0,0], [1,1], [0.4, 0.2], [10.5, 2.0])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Testing/#Testing","page":"Testing","title":"Testing","text":"","category":"section"},{"location":"Testing/#Introduction","page":"Testing","title":"Introduction","text":"","category":"section"},{"location":"Testing/","page":"Testing","title":"Testing","text":"Here we have a little macro to rerun arbitrary code multiple times in case it failes for some reason. It is used to retry testing of downloading from osm, since the server often is not willing to serve a request on the first try.","category":"page"},{"location":"Testing/#API","page":"Testing","title":"API","text":"","category":"section"},{"location":"Testing/","page":"Testing","title":"Testing","text":"Pages = [\"Testing.md\"]","category":"page"},{"location":"Testing/","page":"Testing","title":"Testing","text":"Modules = [CoolWalksUtils]\nPages = [\"Testing.jl\"]","category":"page"},{"location":"Testing/#CoolWalksUtils.@rerun-Tuple{Any, Any}","page":"Testing","title":"CoolWalksUtils.@rerun","text":"@rerun(number, code)\n\nruns the input code at most number times or until it does not throw an error. Used to test code which talks to a server which may not respond on every call.\n\n\n\n\n\n","category":"macro"},{"location":"SunPosition/#Sun-Position","page":"Sun Position","title":"Sun Position","text":"","category":"section"},{"location":"SunPosition/#Introduction","page":"Sun Position","title":"Introduction","text":"","category":"section"},{"location":"SunPosition/","page":"Sun Position","title":"Sun Position","text":"Get the position of the sun in the sky at any location and time, using the ShadowObservatory type.","category":"page"},{"location":"SunPosition/#API","page":"Sun Position","title":"API","text":"","category":"section"},{"location":"SunPosition/","page":"Sun Position","title":"Sun Position","text":"Pages = [\"SunPosition.md\"]","category":"page"},{"location":"SunPosition/","page":"Sun Position","title":"Sun Position","text":"Modules = [CoolWalksUtils]\nPages = [\"SunPosition.jl\"]","category":"page"},{"location":"SunPosition/#CoolWalksUtils.ShadowObservatory","page":"Sun Position","title":"CoolWalksUtils.ShadowObservatory","text":"Type holding all the data related to the center of a dataset like a street network, buildings, trees or their shadows.\n\nname::String: name of city/experiment\nlon::Float64: East-ward longitude of city in degrees\nlat::Float64: North-ward latitude of the city in degrees\ntz::VariableTimeZone: Time zone of the city (used to calculate sun direction at given local time)\n\nThis type is mostly inspired by the AstroLib.Observatory type, but we make it work with the TimeZones package. Note the order of the lon and lat arguments which are renamed and switched compared to the AstroLib implementation.\n\n\n\n\n\n","category":"type"},{"location":"SunPosition/#CoolWalksUtils.local_sunpos-Tuple{Dates.DateTime, ShadowObservatory}","page":"Sun Position","title":"CoolWalksUtils.local_sunpos","text":"local_sunpos(local_time::DateTime, obs::ShadowObservatory; cartesian::Bool=true)\n\nCalculates the position of the sun in the sky at time local_time, at the location specified by obs. Assumes local_time is given in the timezone of obs.tz.\n\nUses AstroLib for all the heavy lifting.\n\nReturn\n\nif cartesian==true:\n\nArray with 3 entries [x,y,z], representing vector pointing towards sun in local, cartesian coordinate system, centered at obs with x pointing east, y pointing north and z pointing up.\n\notherwise:\n\nArray with 2 entries [altitude, azimuth] in degrees. azimuth measured east from north.\n\n\n\n\n\n","category":"method"},{"location":"SunPosition/#CoolWalksUtils.set_observatory!-Tuple{Any, Any, Any}","page":"Sun Position","title":"CoolWalksUtils.set_observatory!","text":"set_observatory!(df, name, timezone; source=[:lon, :lat])\n\ncreates a CoolWalksUtils.ShadowObservatory and adds it to the metadata of df. uses the source column(s) to ge the Extent of the whole dataset.\n\n\n\n\n\n","category":"method"},{"location":"Projection/#Projection-utilities","page":"Projection","title":"Projection utilities","text":"","category":"section"},{"location":"Projection/#Introduction","page":"Projection","title":"Introduction","text":"","category":"section"},{"location":"Projection/","page":"Projection","title":"Projection","text":"CoolWalkUtils.jl specifies a few convenient functions to interpret and reproject different datastructures revolving around ArchGDAL.jl types. (most of this behaviour should probably be part of ArchGDAL.jl, but it is not, as of the time of writing.)","category":"page"},{"location":"Projection/#API","page":"Projection","title":"API","text":"","category":"section"},{"location":"Projection/","page":"Projection","title":"Projection","text":"Pages = [\"Projection.md\"]","category":"page"},{"location":"Projection/","page":"Projection","title":"Projection","text":"OSM_ref","category":"page"},{"location":"Projection/#CoolWalksUtils.OSM_ref","page":"Projection","title":"CoolWalksUtils.OSM_ref","text":"Reference which holds the WSG84 (EPSG4326) ArchGDAL Spatial Reference System with lon-lat order.\n\n\n\n\n\n","category":"constant"},{"location":"Projection/","page":"Projection","title":"Projection","text":"Modules = [CoolWalksUtils]\nPages = [\"Projection.jl\"]","category":"page"},{"location":"Projection/#CoolWalksUtils._execute_projection!-Tuple{ArchGDAL.IGeometry, Any, Any}","page":"Projection","title":"CoolWalksUtils._execute_projection!","text":"_execute_projection!(geometry::ArchGDAL.IGeometry, src, dst)\n_execute_projection!(geometry_iterable, src, dst)\n\nApplies the transformation from src to dst to geometry or the elements of geometry_iterable.\n\n\n\n\n\n","category":"method"},{"location":"Projection/#CoolWalksUtils.apply_wsg_84!-Tuple{Any}","page":"Projection","title":"CoolWalksUtils.apply_wsg_84!","text":"apply_wsg_84!(geometry_container)\n\nreinterprets the coordinates of geometry_container (either ArchGDAL.IGeometry or some iterable of the same) to be in WSG84.\n\n\n\n\n\n","category":"method"},{"location":"Projection/#CoolWalksUtils.crs_local-Tuple{Any, Any}","page":"Projection","title":"CoolWalksUtils.crs_local","text":"crs_local(lon, lat)\n\nbuilds Transverse Mercator ArchGDAL coordinate reference system centered around lon and lat.\n\n\n\n\n\n","category":"method"},{"location":"Projection/#CoolWalksUtils.in_local_coordinates-Tuple{Any, DataFrames.DataFrame, Vararg{Any}}","page":"Projection","title":"CoolWalksUtils.in_local_coordinates","text":"in_local_coordinates(f, obs::ShadowObservatory, args...)\nin_local_coordinates(f, df::DataFrame, args...)\n\nprojects args... to local crs determined by obs, passes all args... to f, projects args... back to global crs and returns the return value of f.\n\nIf a DataFrame is passed as the second entry, the observatory for local projection is taken from metadata(df, \"observatory\").\n\n\n\n\n\n","category":"method"},{"location":"Projection/#CoolWalksUtils.project_back!","page":"Projection","title":"CoolWalksUtils.project_back!","text":"project_back!(geometry_container)\n\nProjects geometry or containers of geometry (iterables) from their respective local system back to WSG84.\n\nIn the case of iterables, we assume all the entries to be in the same crs as the first entry. For DataFrames each colum containing geometry (isgeometry(first(column))) is assumed to be in the same crs as the first entry.\n\nReturns the passed in geometry container.\n\n\n\n\n\n","category":"function"},{"location":"Projection/#CoolWalksUtils.project_local!","page":"Projection","title":"CoolWalksUtils.project_local!","text":"project_local!(geometry_container, observatory::ShadowObservatory)\nproject_local!(df::DataFrame, observatory::ShadowObservatory=metadata(df, \"observatory\"))\n\nProjects geometry or containers of geometry (iterables) to transverse mercator centered at (lon, lat) in observatory.\n\nIn the case of iterables, we assume all the entries to be in the same crs as the first entry. For DataFrames each colum containing geometry (determined by isgeometry(first(column))) is assumed to be in the same crs as the first entry.\n\nReturns the passed geometry container.\n\nproject_local!(container, lon, lat)\n\nSame as above, but allows to specify the center of the projection via lon and lat in degrees.\n\n\n\n\n\n","category":"function"},{"location":"Projection/#CoolWalksUtils.reinterp_crs!-Tuple{Any, Any}","page":"Projection","title":"CoolWalksUtils.reinterp_crs!","text":"reinterp_crs!(geometry_container, crs)\n\nreinterprets the coordinates of geometry_container (either ArchGDAL.IGeometry or some iterable of the same) to be in crs.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CoolWalksUtils","category":"page"},{"location":"#CoolWalksUtils","page":"Home","title":"CoolWalksUtils","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CoolWalksUtils.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package contains general utilities used extensively in:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ShadowGraphs.jl\nCompositeBuildings.jl\nTreeLoaders.jl","category":"page"},{"location":"Extents/#Extent-Utilities","page":"Extents","title":"Extent Utilities","text":"","category":"section"},{"location":"Extents/#Introduction","page":"Extents","title":"Introduction","text":"","category":"section"},{"location":"Extents/","page":"Extents","title":"Extents","text":"These are a few methods to generate and work with Extents.Extent objects. Most of this will ideally be moved to GeoInterface.jl or to Extents.jl itself. Until then, we keep it here.","category":"page"},{"location":"Extents/#API","page":"Extents","title":"API","text":"","category":"section"},{"location":"Extents/","page":"Extents","title":"Extents","text":"Pages = [\"Extents.md\"]","category":"page"},{"location":"Extents/","page":"Extents","title":"Extents","text":"Modules = [CoolWalksUtils]\nPages = [\"Extents.jl\"]","category":"page"},{"location":"Extents/#CoolWalksUtils.apply_extent!-Tuple{Any, Any}","page":"Extents","title":"CoolWalksUtils.apply_extent!","text":"apply_extent!(df, extent; source=[:lon, :lat])\n\ntrim df to only contain rows where extent_contains(extent, source...) is true.\n\n\n\n\n\n","category":"method"},{"location":"Extents/#CoolWalksUtils.extent_center-Tuple{Any}","page":"Extents","title":"CoolWalksUtils.extent_center","text":"extent_center(extent)\n\ncalculates the centerpoint of extent. Return a NamedTuple with the same keys as extent.\n\n\n\n\n\n","category":"method"},{"location":"Extents/#CoolWalksUtils.extent_contains-Tuple{Extents.Extent, Any, Any}","page":"Extents","title":"CoolWalksUtils.extent_contains","text":"extent_contains(a::Extent, X, Y)\n\nChecks if the extent a contains the point given by X and Y.\n\n\n\n\n\n","category":"method"},{"location":"Extents/#CoolWalksUtils.extent_contains-Tuple{Extents.Extent, Any}","page":"Extents","title":"CoolWalksUtils.extent_contains","text":"extent_contains(a::Extent, geometry)\n\nChecks if the GeoInterface.extent of geometry is fully contained in extent a.\n\n\n\n\n\n","category":"method"},{"location":"Extents/#CoolWalksUtils.extent_contains-Tuple{Extents.Extent, Extents.Extent}","page":"Extents","title":"CoolWalksUtils.extent_contains","text":"extent_contains(a::Extent, b::Extent)\n\nChecks if the extent b is fully contained in extent a.\n\n\n\n\n\n","category":"method"},{"location":"Extents/#CoolWalksUtils.geoiter_extent-Tuple{Any, Any}","page":"Extents","title":"CoolWalksUtils.geoiter_extent","text":"geoiter_extent(X, Y)\n\nconstructs the Extent from two iterables representing x and y coordinates. (Note that Numbers are iterable: geoiter_extent(3.5, 3) works.)\n\n\n\n\n\n","category":"method"},{"location":"Extents/#CoolWalksUtils.geoiter_extent-Tuple{Any}","page":"Extents","title":"CoolWalksUtils.geoiter_extent","text":"geoiter_extent(geo_iter)\n\nconstructs the Extent from an iterable with GeoInterface compatible elements.\n\n\n\n\n\n","category":"method"},{"location":"RTreeBuilding/#RTree-Building","page":"RTrees","title":"RTree Building","text":"","category":"section"},{"location":"RTreeBuilding/#Introduction","page":"RTrees","title":"Introduction","text":"","category":"section"},{"location":"RTreeBuilding/","page":"RTrees","title":"RTrees","text":"Utilities to build SpatialIndexing RTrees out of ArchGDAL geometries or dataframes containing such.","category":"page"},{"location":"RTreeBuilding/#API","page":"RTrees","title":"API","text":"","category":"section"},{"location":"RTreeBuilding/","page":"RTrees","title":"RTrees","text":"Pages = [\"RTreeBuilding.md\"]","category":"page"},{"location":"RTreeBuilding/","page":"RTrees","title":"RTrees","text":"Modules = [CoolWalksUtils]\nPages = [\"RTreeBuilding.jl\"]","category":"page"},{"location":"RTreeBuilding/#CoolWalksUtils.build_rtree","page":"RTrees","title":"CoolWalksUtils.build_rtree","text":"build_rtree(geom_arr::AbstractArray, data_arr=[nothing])\n\nbuilds SpatialIndexing.RTree{Float64, 2} from an array containing ArchGDAL.IGeometrys. The value of an entry in the RTree is a named tuple with: (orig=original_geometry,prep=prepared_geometry, data=data_entry). orig is the original object, an element from geom_arr. prep is the prepared geometry, derived from orig. The latter one can be used in a few ArchGDAL functions to get higher performance, for example in intersection testing, because relevant values get precomputed and cashed in the prepared geometry, rather than recomputed on every test. data holds the entry in data_arr at the index of orig in geom_arr.\n\nThe type of the val tuple is determined by the eltype of geom_arr and data_arr. For performance sake, make sure they are concrete.\n\n\n\n\n\n","category":"function"},{"location":"RTreeBuilding/#CoolWalksUtils.build_rtree-Tuple{DataFrames.DataFrame}","page":"RTrees","title":"CoolWalksUtils.build_rtree","text":"build_rtree(df::DataFrame)\n\nbuilds SpatialIndexing.RTree{Float64, 2} from a DataFrame containing at least a column named geometry. The value of an entry in the RTree is a named tuple with: (orig=original_geometry, prep=prepared_geometry, data=dataframe_row). orig is the same geometry as in row.geometry, and prep is the prepared geometry, derived from orig. It can be used in a few ArchGDAL functions to get higher performance, for example in intersection testing, because relevant values get precomputed and cashed in the prepared geometry, rather than recomputed on every test.\n\nNote that only the first element in these tests can be a prepared geometry, for example ArchGDAL.intersects(normal_geom, prepared_geom) is a highway to segfault-town, while ArchGDAL.intersects(prepared_geom, normal_geom) is fine and great.\n\nThe data entry is a reference to the row of the original dataframe df, providing access to all relevant data.\n\n\n\n\n\n","category":"method"},{"location":"RTreeBuilding/#CoolWalksUtils.rect_from_geom-Tuple{Any}","page":"RTrees","title":"CoolWalksUtils.rect_from_geom","text":"rect_from_geom(geom; buffer=0.0)\n\nbuilds SpatialIndexing.Rect with the extent of the geometry geom and a buffer of buffer added to each edge of the Rect. Ideally, SpatialIndexing.jl would integrate with GeoInterface.jl or at least Extents.jl, making this function obsolete.\n\n\n\n\n\n","category":"method"}]
}
